<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xue.Zeng</title>
    <link>https://xue2zeng.github.io/</link>
    <description>Recent content on Xue.Zeng</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 29 Sep 2019 13:06:38 +0800</lastBuildDate>
    
	<atom:link href="https://xue2zeng.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>并发-传统同步机制</title>
      <link>https://xue2zeng.github.io/post/language/go/sync/</link>
      <pubDate>Sun, 29 Sep 2019 13:06:38 +0800</pubDate>
      
      <guid>https://xue2zeng.github.io/post/language/go/sync/</guid>
      <description>在CSP模型下尽量少用传统同步机制，尽量使用chanel进行通信。Go语言中原子操作由内置的标准库sync/atomic提供。 sync.Mutex 互斥量是一种</description>
    </item>
    
    <item>
      <title>并发-Select</title>
      <link>https://xue2zeng.github.io/post/language/go/select/</link>
      <pubDate>Sun, 29 Sep 2019 11:43:05 +0800</pubDate>
      
      <guid>https://xue2zeng.github.io/post/language/go/select/</guid>
      <description>官方文档有关select的描述 A &amp;ldquo;select&amp;rdquo; statement chooses which of a set of possible send or receive operations will proceed. It looks similar to a &amp;ldquo;switch&amp;rdquo; statement but with the cases all referring to communication operations. 一个select语句用来选择哪个case中的发</description>
    </item>
    
    <item>
      <title>并发-Channel</title>
      <link>https://xue2zeng.github.io/post/language/go/channel/</link>
      <pubDate>Sat, 28 Sep 2019 15:56:51 +0800</pubDate>
      
      <guid>https://xue2zeng.github.io/post/language/go/channel/</guid>
      <description>Channel主要被用来在多个Goroutione之间传递数据，并且还会保证其过程的同步。总是遵循先入先出（First In First Out）的规则，保</description>
    </item>
    
    <item>
      <title>并发-Goroutine(协程)</title>
      <link>https://xue2zeng.github.io/post/language/go/goroutine/</link>
      <pubDate>Sat, 28 Sep 2019 09:57:11 +0800</pubDate>
      
      <guid>https://xue2zeng.github.io/post/language/go/goroutine/</guid>
      <description>轻量级&amp;rdquo;线程&amp;rdquo; 线程（Thread）：有时被称为轻量级进程(Lightweight Process，LWP），是程序执行</description>
    </item>
    
    <item>
      <title>性能调优-PProf</title>
      <link>https://xue2zeng.github.io/post/language/go/performance/</link>
      <pubDate>Mon, 16 Sep 2019 21:02:52 +0800</pubDate>
      
      <guid>https://xue2zeng.github.io/post/language/go/performance/</guid>
      <description>PProf pprof 是用于可视化和分析性能分析数据的工具，以 profile.proto 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告） profile.proto 是一个 Protocol Buffer v3 的描述</description>
    </item>
    
    <item>
      <title>调试与测试</title>
      <link>https://xue2zeng.github.io/post/language/go/testing/</link>
      <pubDate>Mon, 16 Sep 2019 20:22:23 +0800</pubDate>
      
      <guid>https://xue2zeng.github.io/post/language/go/testing/</guid>
      <description>传统测试 测试数据与测试逻辑混在一起 出错信息不明确 一旦一个数据出错，测试全部结束 @Test public void testAdd() { assertEquals(3, add(1, 2)); assertEquals(2, add(0, 2)); assertEquals(0, add(0, 0)); assertEquals(0, add(-1, 1)); assertEquals(Integer.MIN_VALUE, add(1, Integer.MAX_VALUE)); } 表格驱动测试 测试数据</description>
    </item>
    
    <item>
      <title>资源管理与错误处理</title>
      <link>https://xue2zeng.github.io/post/language/go/resourceerror/</link>
      <pubDate>Sun, 08 Sep 2019 18:32:51 +0800</pubDate>
      
      <guid>https://xue2zeng.github.io/post/language/go/resourceerror/</guid>
      <description>Defer 调用特点 确保调用在函数结束时发生 defer列表为后进先出，参数在defer语句时才计算 func tryDefer() { defer fmt.Println(1) defer fmt.Println(2) fmt.Println(3) //return panic(&amp;#34;error occurred&amp;#34;) fmt.Println(4) } --------- 3 2 1 常见使用defer</description>
    </item>
    
    <item>
      <title>函数式编程</title>
      <link>https://xue2zeng.github.io/post/language/go/functional/</link>
      <pubDate>Sun, 08 Sep 2019 14:15:09 +0800</pubDate>
      
      <guid>https://xue2zeng.github.io/post/language/go/functional/</guid>
      <description>&amp;ldquo;正统&amp;rdquo;函数式编程 不可变性：不能有状态，只有常量和函数 函数只能有一个参数 // 正统函数式编程 type iAdder func(int) (int, iAdder) func adder(base int) iAdder { return func(v int) (int,</description>
    </item>
    
    <item>
      <title>面向接口</title>
      <link>https://xue2zeng.github.io/post/language/go/interfaceoriented/</link>
      <pubDate>Sat, 07 Sep 2019 21:11:31 +0800</pubDate>
      
      <guid>https://xue2zeng.github.io/post/language/go/interfaceoriented/</guid>
      <description>Duck Typing（鸭子类型） 在维基百科中是这样定义的： 鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的</description>
    </item>
    
    <item>
      <title>面向对象</title>
      <link>https://xue2zeng.github.io/post/language/go/objectoriented/</link>
      <pubDate>Sat, 07 Sep 2019 10:28:18 +0800</pubDate>
      
      <guid>https://xue2zeng.github.io/post/language/go/objectoriented/</guid>
      <description>Go语言仅支持封装，不支持继承和多态 Go语言没有class，只有struct 结构体和方法 创建 type Node struct { Value int Left, Right *Node } 定义方法 func CreateNode(value int) *Node { return &amp;amp;Node{Value: value} } func</description>
    </item>
    
    <item>
      <title>Hugo结合Github搭建博客</title>
      <link>https://xue2zeng.github.io/post/toolkit/hugo%E7%BB%93%E5%90%88github/</link>
      <pubDate>Mon, 26 Aug 2019 18:36:09 +0800</pubDate>
      
      <guid>https://xue2zeng.github.io/post/toolkit/hugo%E7%BB%93%E5%90%88github/</guid>
      <description>安装Hugo macOS环境 brew install hugo # 检测安装成功 hugo version Hugo Static Site Generator v0.55.6/extended darwin/amd64 BuildDate: 2019-08-26T15:23:01Z 生成站点 使用hugo创建blog站点 hugo new site blog cd blog # 目录结构 tree blog #blog #├── archetypes</description>
    </item>
    
    <item>
      <title>容器</title>
      <link>https://xue2zeng.github.io/post/language/go/container/</link>
      <pubDate>Sun, 25 Aug 2019 16:44:25 +0800</pubDate>
      
      <guid>https://xue2zeng.github.io/post/language/go/container/</guid>
      <description>数组 切片(Slice) 1、扩展 arry := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} fmt.Println(&amp;#34;arry = &amp;#34;, arry) s1 = arry[2:6] s2 = s1[3:5] Slice可以向后扩展，不可以向前扩展 s[i]不可以超越len(s</description>
    </item>
    
    <item>
      <title>程序结构</title>
      <link>https://xue2zeng.github.io/post/language/go/structure/</link>
      <pubDate>Sun, 18 Aug 2019 09:56:38 +0800</pubDate>
      
      <guid>https://xue2zeng.github.io/post/language/go/structure/</guid>
      <description>条件语句 1、if&amp;hellip;else&amp;hellip; 条件内可以赋值 条件内赋值的变量作用域就存在于这个if语句里 if contents, err := ioutil.ReadFile(filename); err == nil { fmt.Println(string(contents)) } else {</description>
    </item>
    
    <item>
      <title>Go 变量</title>
      <link>https://xue2zeng.github.io/post/language/go/variable/</link>
      <pubDate>Sat, 03 Aug 2019 16:42:15 +0800</pubDate>
      
      <guid>https://xue2zeng.github.io/post/language/go/variable/</guid>
      <description>变量定义 1、使用var关键字(变量类型写在变量名之后) var a, b, c bool var s1, s2 string = &amp;ldquo;hello&amp;rdquo;, &amp;ldquo;world&amp;rdquo; 可定义在函数体内或直接定义在包内 使用var()集中定义变量 var (</description>
    </item>
    
    <item>
      <title>GO 概述</title>
      <link>https://xue2zeng.github.io/post/language/go/overview/</link>
      <pubDate>Sat, 03 Aug 2019 10:49:44 +0800</pubDate>
      
      <guid>https://xue2zeng.github.io/post/language/go/overview/</guid>
      <description>区别于其它语言 没有&amp;rdquo; 对象&amp;rdquo;，没有继承、多态，没有泛型，没有try/catch 有接口，函数式编程，CSP并发模型（go</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://xue2zeng.github.io/about/</link>
      <pubDate>Thu, 01 Aug 2019 19:09:06 +0800</pubDate>
      
      <guid>https://xue2zeng.github.io/about/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>